<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paragraph Splitter</title>
    <!-- Tailwind CSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Vue.js via CDN -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        /* Any custom styles beyond Tailwind if needed */
        .fade-enter-active, .fade-leave-active {
            transition: opacity 0.3s;
        }
        .fade-enter-from, .fade-leave-to {
            opacity: 0;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <div id="app" class="container mx-auto px-4 py-8 max-w-5xl">
        <header class="mb-8 text-center">
            <h1 class="text-3xl font-bold text-gray-800">Paragraph Splitter</h1>
            <p class="text-gray-600">Split your text into logical paragraphs using AI</p>
        </header>

        <main class="grid grid-cols-1 md:grid-cols-3 gap-6">
            <!-- Input Section -->
            <div class="bg-white rounded-lg shadow-md p-4">
                <h2 class="text-xl font-semibold mb-2 text-gray-700">Input Text</h2>
                <textarea 
                    v-model="inputText" 
                    class="w-full h-64 p-3 border border-gray-300 rounded resize-none focus:outline-none focus:ring-2 focus:ring-blue-500"
                    placeholder="Paste your unparagraphed text here..."
                ></textarea>
                <div class="mt-4 flex flex-col gap-2">
                    <div class="flex justify-between items-center">
                        <span class="text-sm text-gray-500">{{ inputStats }}</span>
                        <button 
                            @click="processText" 
                            class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md transition-colors"
                            :disabled="isProcessing || !inputText.trim()"
                            :class="{'opacity-50 cursor-not-allowed': isProcessing || !inputText.trim()}"
                        >
                            <span v-if="isProcessing">Processing...</span>
                            <span v-else>Split Paragraphs</span>
                        </button>
                    </div>
                    <!-- Progress Bar -->
                    <div v-if="isProcessing" class="w-full">
                        <div class="w-full bg-gray-200 rounded-full h-2.5">
                            <div class="bg-blue-600 h-2.5 rounded-full" :style="{ width: `${progressPercent}%` }"></div>
                        </div>
                        <p class="text-sm text-gray-600 mt-1">{{ progressStatus }} ({{ Math.round(progressPercent) }}%)</p>
                    </div>
                </div>
            </div>

            <!-- Paragraphed Output Section -->
            <div class="bg-white rounded-lg shadow-md p-4">
                <h2 class="text-xl font-semibold mb-2 text-gray-700">Paragraphed Text</h2>
                <textarea 
                    v-model="outputText" 
                    class="w-full h-64 p-3 border border-gray-300 rounded resize-none focus:outline-none focus:ring-2 focus:ring-blue-500"
                    placeholder="Paragraphed text will appear here..."
                ></textarea>
                <div class="mt-4 flex flex-col gap-2">
                    <div class="flex justify-between items-center">
                        <span class="text-sm text-gray-500">{{ outputStats }}</span>
                        <div class="flex gap-2">
                            <button 
                                @click="copyToClipboard('output')" 
                                class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-md transition-colors"
                                :disabled="!outputText"
                                :class="{'opacity-50 cursor-not-allowed': !outputText}"
                            >
                                <span v-if="copied === 'output'">Copied!</span>
                                <span v-else>Copy</span>
                            </button>
                            <button 
                                @click="processSections" 
                                class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md transition-colors"
                                :disabled="isSectioning || !outputText.trim()"
                                :class="{'opacity-50 cursor-not-allowed': isSectioning || !outputText.trim()}"
                            >
                                <span v-if="isSectioning">Processing...</span>
                                <span v-else>Add Sections</span>
                            </button>
                        </div>
                    </div>
                    <!-- Section Progress Bar -->
                    <div v-if="isSectioning" class="w-full">
                        <div class="w-full bg-gray-200 rounded-full h-2.5">
                            <div class="bg-blue-600 h-2.5 rounded-full" :style="{ width: `${sectionProgressPercent}%` }"></div>
                        </div>
                        <p class="text-sm text-gray-600 mt-1">{{ sectionProgressStatus }} ({{ Math.round(sectionProgressPercent) }}%)</p>
                    </div>
                </div>
            </div>

            <!-- Sectioned Output Section -->
            <div class="bg-white rounded-lg shadow-md p-4">
                <h2 class="text-xl font-semibold mb-2 text-gray-700">Sectioned Text</h2>
                <textarea 
                    v-model="sectionedText" 
                    class="w-full h-64 p-3 border border-gray-300 rounded resize-none focus:outline-none focus:ring-2 focus:ring-blue-500"
                    placeholder="Sectioned text with headings will appear here..."
                    readonly
                ></textarea>
                <div class="mt-4 flex justify-between items-center">
                    <span class="text-sm text-gray-500">{{ sectionedStats }}</span>
                    <button 
                        @click="copyToClipboard('sectioned')" 
                        class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-md transition-colors"
                        :disabled="!sectionedText"
                        :class="{'opacity-50 cursor-not-allowed': !sectionedText}"
                    >
                        <span v-if="copied === 'sectioned'">Copied!</span>
                        <span v-else>Copy</span>
                    </button>
                </div>
            </div>
        </main>

        <!-- Settings Panel -->
        <div class="mt-8">
            <button 
                @click="showSettings = !showSettings" 
                class="flex items-center text-gray-700 hover:text-blue-600 transition-colors"
            >
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.533 1.533 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.533 1.533 0 01.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106a1.532 1.532 0 01-2.287-.947zM10 13a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd" />
                </svg>
                <span>{{ showSettings ? 'Hide Settings' : 'Show Settings' }}</span>
            </button>

            <transition name="fade">
                <div v-if="showSettings" class="mt-4 bg-white rounded-lg shadow-md p-6">
                    <h3 class="text-lg font-semibold mb-4 text-gray-700">API Settings</h3>
                    
                    <div class="mb-4">
                        <label class="block text-gray-700 text-sm font-medium mb-2" for="apiEndpoint">
                            API Endpoint
                        </label>
                        <input 
                            id="apiEndpoint" 
                            v-model="settings.apiEndpoint" 
                            type="text" 
                            class="w-full p-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                            placeholder="https://api.openai.com/v1/chat/completions"
                        >
                    </div>
                    
                    <div class="mb-4">
                        <label class="block text-gray-700 text-sm font-medium mb-2" for="apiKey">
                            API Key
                        </label>
                        <input 
                            id="apiKey" 
                            v-model="settings.apiKey" 
                            type="password" 
                            class="w-full p-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                            placeholder="Your API key"
                        >
                    </div>
                    
                    <div class="mb-4">
                        <label class="block text-gray-700 text-sm font-medium mb-2" for="model">
                            Model
                        </label>
                        <input 
                            id="model" 
                            v-model="settings.model" 
                            type="text" 
                            class="w-full p-2 border border-gray-300 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                            placeholder="gpt-4o-mini"
                        >
                    </div>
                    
                    <div class="mb-4">
                        <label class="block text-gray-700 text-sm font-medium mb-2" for="temperature">
                            Temperature: {{ settings.temperature }}
                        </label>
                        <input 
                            id="temperature" 
                            v-model="settings.temperature" 
                            type="range" 
                            min="0" 
                            max="1" 
                            step="0.1" 
                            class="w-full"
                        >
                    </div>
                    
                    <div class="flex justify-end">
                        <button 
                            @click="saveSettings" 
                            class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md transition-colors"
                        >
                            Save Settings
                        </button>
                    </div>
                </div>
            </transition>
        </div>

        <!-- Error Alert -->
        <transition name="fade">
            <div v-if="error" class="fixed bottom-4 right-4 bg-red-100 border-l-4 border-red-500 text-red-700 p-4 max-w-md rounded shadow-md">
                <div class="flex">
                    <div class="py-1">
                        <svg class="h-6 w-6 text-red-500 mr-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                        </svg>
                    </div>
                    <div>
                        <p class="font-bold">Error</p>
                        <p>{{ error }}</p>
                    </div>
                </div>
                <button @click="error = ''" class="absolute top-2 right-2 text-red-700">
                    <svg class="h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
                    </svg>
                </button>
            </div>
        </transition>
    </div>

    <script>
        const { createApp, ref, computed, watch, onMounted } = Vue;

        createApp({
            setup() {
                // State
                const inputText = ref('');
                const outputText = ref('');
                const sectionedText = ref('');
                const isProcessing = ref(false);
                const isSectioning = ref(false);
                const copied = ref('');
                const showSettings = ref(false);
                const error = ref('');
                const progressPercent = ref(0);
                const progressStatus = ref('');
                const sectionProgressPercent = ref(0);
                const sectionProgressStatus = ref('');
                const settings = ref({
                    apiEndpoint: 'https://api.openai.com/v1/chat/completions',
                    apiKey: '',
                    model: 'gpt-4o-mini',
                    temperature: 0.1
                });

                // Computed properties
                const inputStats = computed(() => {
                    const text = inputText.value.trim();
                    if (!text) return 'No text';
                    
                    const words = text.split(/\s+/).length;
                    const chars = text.length;
                    const sentences = splitSentences(text).length;
                    return `${sentences} sentences, ${words} words, ${chars} characters`;
                });

                const outputStats = computed(() => {
                    const text = outputText.value.trim();
                    if (!text) return 'No text';
                    
                    const paragraphs = text.split(/\n\n+/).length;
                    const words = text.split(/\s+/).length;
                    const sentences = splitSentences(text).length;
                    return `${paragraphs} paragraphs, ${sentences} sentences, ${words} words`;
                });

                const sectionedStats = computed(() => {
                    const text = sectionedText.value.trim();
                    if (!text) return 'No text';
                    
                    const sections = (text.match(/^## .+$/gm) || []).length;
                    const paragraphs = text.split(/\n\n+/).length - sections; // Subtract section headings
                    const words = text.split(/\s+/).length - sections * 2; // Subtract "## Heading" words
                    return `${sections} sections, ${paragraphs} paragraphs, ${words} words`;
                });

                // Methods
                const loadSettings = () => {
                    const savedSettings = localStorage.getItem('paragraphSplitterSettings');
                    if (savedSettings) {
                        try {
                            const parsed = JSON.parse(savedSettings);
                            settings.value = { ...settings.value, ...parsed };
                        } catch (e) {
                            console.error('Failed to parse saved settings:', e);
                        }
                    }
                };

                const saveSettings = () => {
                    localStorage.setItem('paragraphSplitterSettings', JSON.stringify(settings.value));
                    showSettings.value = false;
                };

                const splitSentences = (text) => {
                    // Split on punctuation (including groups of consecutive punctuation) followed by whitespace
                    // This handles ellipses and other consecutive punctuation as a single split point
                    const sentences = text.replace(/([.!?]+)\s+/g, "$1\n").split("\n");
                    return sentences.filter(s => s.trim().length > 0);
                };

                const preparePrompt = (sentences) => {
                    // Number each sentence for the LLM
                    const numberedSentences = sentences.map((s, i) => `${i + 1}. ${s}`).join(' ');
                    
                    // Create the prompt for the LLM
                    return {
                        role: "user",
                        content: `Identify which sentences should be grouped together into paragraphs. Return ONLY the paragraph structure in this format: 'P1: 1-4; P2: 5-9; ...' with no additional text.\n\n${numberedSentences}`
                    };
                };

                const callLLMService = async (prompt) => {
                    try {
                        const response = await fetch(settings.value.apiEndpoint, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${settings.value.apiKey}`
                            },
                            body: JSON.stringify({
                                model: settings.value.model,
                                messages: [prompt],
                                temperature: parseFloat(settings.value.temperature)
                            })
                        });

                        if (!response.ok) {
                            const errorData = await response.json();
                            throw new Error(errorData.error?.message || 'API request failed');
                        }

                        const data = await response.json();
                        return data.choices[0].message.content.trim();
                    } catch (e) {
                        throw new Error(`API Error: ${e.message}`);
                    }
                };

                const parseParagraphStructure = (structure) => {
                    // Parse the LLM response to get paragraph structure
                    // Expected format: "P1: 1-4; P2: 5-9; P3: 10-15"
                    const paragraphs = [];
                    
                    // Extract paragraph ranges using regex
                    const regex = /P\d+:\s*(\d+)-(\d+)/g;
                    let match;
                    
                    while ((match = regex.exec(structure)) !== null) {
                        const start = parseInt(match[1]);
                        const end = parseInt(match[2]);
                        
                        if (!isNaN(start) && !isNaN(end)) {
                            paragraphs.push({ start, end });
                        }
                    }
                    
                    return paragraphs;
                };

                const reconstructParagraphs = (sentences, paragraphStructure) => {
                    // Reconstruct the text with paragraph breaks based on the structure
                    let result = '';
                    let currentIndex = 1;
                    
                    for (const paragraph of paragraphStructure) {
                        const paragraphSentences = [];
                        
                        for (let i = paragraph.start - 1; i < paragraph.end; i++) {
                            if (i < sentences.length) {
                                paragraphSentences.push(sentences[i]);
                            }
                        }
                        
                        if (paragraphSentences.length > 0) {
                            result += paragraphSentences.join(' ') + '\n\n';
                        }
                        
                        currentIndex = paragraph.end + 1;
                    }
                    
                    // Add any remaining sentences as a final paragraph
                    if (currentIndex <= sentences.length) {
                        const remainingSentences = sentences.slice(currentIndex - 1);
                        result += remainingSentences.join(' ');
                    }
                    
                    return result.trim();
                };

                // Batch processing functions
                const createBatches = (sentences, batchSize = 50, overlap = 10) => {
                    const batches = [];
                    for (let i = 0; i < sentences.length; i += batchSize - overlap) {
                        const end = Math.min(i + batchSize, sentences.length);
                        batches.push({
                            sentences: sentences.slice(i, end),
                            startIndex: i + 1, // 1-based indexing for the LLM
                            endIndex: end
                        });
                    }
                    return batches;
                };

                const adjustParagraphStructure = (paragraphStructure, isFirstBatch, isLastBatch, overlap, batchStartIndex) => {
                    if (paragraphStructure.length === 0) return [];
                    
                    // Adjust for batch position
                    if (!isFirstBatch) {
                        // For non-first batches, ignore decisions for the first 'overlap' sentences
                        paragraphStructure = paragraphStructure.filter(p => p.end > overlap);
                        
                        // Adjust indices to account for overlap
                        paragraphStructure = paragraphStructure.map(p => ({
                            start: Math.max(p.start, overlap + 1),
                            end: p.end
                        }));
                    }
                    
                    // Adjust indices to global sentence positions
                    return paragraphStructure.map(p => ({
                        start: p.start + batchStartIndex - 1,
                        end: p.end + batchStartIndex - 1
                    }));
                };

                const processBatch = async (batch, batchIndex, totalBatches, overlap) => {
                    progressStatus.value = `Processing batch ${batchIndex + 1} of ${totalBatches}...`;
                    
                    // Process this batch
                    const batchSentences = batch.sentences;
                    const prompt = preparePrompt(batchSentences);
                    const llmResponse = await callLLMService(prompt);
                    const paragraphStructure = parseParagraphStructure(llmResponse);
                    
                    if (paragraphStructure.length === 0) {
                        throw new Error(`Failed to parse paragraph structure for batch ${batchIndex + 1}`);
                    }
                    
                    // Adjust paragraph structure based on batch position
                    const adjustedStructure = adjustParagraphStructure(
                        paragraphStructure, 
                        batchIndex === 0, // isFirstBatch
                        batchIndex === totalBatches - 1, // isLastBatch
                        overlap,
                        batch.startIndex
                    );
                    
                    return adjustedStructure;
                };

                const processText = async () => {
                    if (!inputText.value.trim() || isProcessing.value) return;
                    
                    if (!settings.value.apiKey) {
                        error.value = 'Please enter your API key in the settings';
                        showSettings.value = true;
                        return;
                    }
                    
                    isProcessing.value = true;
                    error.value = '';
                    progressPercent.value = 0;
                    progressStatus.value = 'Preparing to process...';
                    
                    try {
                        // Split text into sentences
                        const sentences = splitSentences(inputText.value);
                        
                        if (sentences.length === 0) {
                            throw new Error('No valid sentences found in the input text');
                        }
                        
                        // For small texts, process in a single batch
                        if (sentences.length <= 50) {
                            progressStatus.value = 'Processing text...';
                            progressPercent.value = 30;
                            
                            // Prepare prompt for LLM
                            const prompt = preparePrompt(sentences);
                            
                            // Call LLM service
                            const llmResponse = await callLLMService(prompt);
                            progressPercent.value = 70;
                            
                            // Parse paragraph structure from LLM response
                            const paragraphStructure = parseParagraphStructure(llmResponse);
                            
                            if (paragraphStructure.length === 0) {
                                throw new Error('Failed to parse paragraph structure from LLM response');
                            }
                            
                            // Reconstruct paragraphs
                            progressStatus.value = 'Reconstructing paragraphs...';
                            const paragraphedText = reconstructParagraphs(sentences, paragraphStructure);
                            
                            // Update output
                            outputText.value = paragraphedText;
                            progressPercent.value = 100;
                            progressStatus.value = 'Processing complete!';
                        } else {
                            // Process in batches for larger texts
                            const batchSize = 50;
                            const overlap = 10;
                            const batches = createBatches(sentences, batchSize, overlap);
                            
                            progressStatus.value = `Processing text in ${batches.length} batches...`;
                            
                            // Process each batch
                            const allParagraphStructures = [];
                            for (let i = 0; i < batches.length; i++) {
                                progressPercent.value = (i / batches.length) * 90; // Reserve 10% for final reconstruction
                                
                                const batchStructure = await processBatch(batches[i], i, batches.length, overlap);
                                allParagraphStructures.push(...batchStructure);
                            }
                            
                            // Sort paragraph structures by start index
                            allParagraphStructures.sort((a, b) => a.start - b.start);
                            
                            // Merge overlapping paragraphs
                            const mergedStructures = [];
                            for (const paragraph of allParagraphStructures) {
                                // Skip if this paragraph is entirely contained within the previous one
                                if (mergedStructures.length > 0) {
                                    const lastParagraph = mergedStructures[mergedStructures.length - 1];
                                    if (paragraph.start >= lastParagraph.start && paragraph.end <= lastParagraph.end) {
                                        continue;
                                    }
                                    
                                    // Merge with previous paragraph if they overlap
                                    if (paragraph.start <= lastParagraph.end) {
                                        lastParagraph.end = Math.max(lastParagraph.end, paragraph.end);
                                        continue;
                                    }
                                }
                                
                                mergedStructures.push(paragraph);
                            }
                            
                            // Reconstruct paragraphs
                            progressStatus.value = 'Reconstructing paragraphs...';
                            progressPercent.value = 95;
                            const paragraphedText = reconstructParagraphs(sentences, mergedStructures);
                            
                            // Update output
                            outputText.value = paragraphedText;
                            progressPercent.value = 100;
                            progressStatus.value = 'Processing complete!';
                        }
                    } catch (e) {
                        error.value = e.message;
                        console.error('Processing error:', e);
                    } finally {
                        isProcessing.value = false;
                    }
                };

                // Section processing functions
                const createParagraphBatches = (paragraphs, batchSize = 20, previousSectionEnd = null) => {
                    const batches = [];
                    let i = 0;
                    
                    // For the first batch, just take the first batchSize paragraphs
                    let end = Math.min(i + batchSize, paragraphs.length);
                    batches.push({
                        paragraphs: paragraphs.slice(i, end),
                        startIndex: i,
                        endIndex: end - 1
                    });
                    
                    // For subsequent batches, include the last section from the previous batch
                    i = end;
                    while (i < paragraphs.length) {
                        // If we have a previousSectionEnd from the last batch, adjust the start
                        // to include those paragraphs in this batch
                        let batchStart = i;
                        if (previousSectionEnd !== null && batches.length > 0) {
                            batchStart = previousSectionEnd;
                        }
                        
                        end = Math.min(i + batchSize, paragraphs.length);
                        
                        // Ensure we don't create a batch with only overlapping paragraphs
                        if (end > batchStart) {
                            batches.push({
                                paragraphs: paragraphs.slice(batchStart, end),
                                startIndex: batchStart,
                                endIndex: end - 1,
                                overlapStart: batchStart,
                                overlapEnd: i - 1
                            });
                        }
                        
                        i = end;
                    }
                    
                    return batches;
                };

                const prepareSectionPrompt = (paragraphs) => {
                    // Number each paragraph for the LLM
                    // Truncate long paragraphs to avoid token limits
                    const numberedParagraphs = paragraphs.map((p, i) => `P${i + 1}: ${p.substring(0, 150)}${p.length > 150 ? '...' : ''}`).join('\n\n');
                    
                    // Create the prompt for the LLM with clearer instructions
                    return {
                        role: "user",
                        content: `Analyze these paragraphs and identify logical sections. For each section, provide a concise, descriptive heading.

IMPORTANT: Return ONLY the section structure in EXACTLY this format: 
'S1[Heading Title]: P1-P5; S2[Another Heading]: P6-P9; ...'

Do not include any additional text, explanations, or formatting. Just the section structure as specified.
Every paragraph must be included in exactly one section.
Do not skip any paragraphs.

${numberedParagraphs}`
                    };
                };

                const parseSectionStructure = (response) => {
                    const sections = [];
                    
                    // Log the response for debugging
                    console.log("LLM Response:", response);
                    
                    // Try multiple regex patterns to handle different possible formats
                    
                    // Pattern 1: Standard format "S1[Heading]: P1-P5"
                    let regex = /S\d+\s*\[\s*(.*?)\s*\]\s*:\s*P(\d+)\s*-\s*P(\d+)/g;
                    let match;
                    
                    while ((match = regex.exec(response)) !== null) {
                        const heading = match[1].trim();
                        const startParagraph = parseInt(match[2]);
                        const endParagraph = parseInt(match[3]);
                        
                        console.log(`Found section: "${heading}" from P${startParagraph} to P${endParagraph}`);
                        
                        if (heading && !isNaN(startParagraph) && !isNaN(endParagraph)) {
                            sections.push({
                                heading,
                                start: startParagraph,
                                end: endParagraph
                            });
                        }
                    }
                    
                    // If no sections found with the first pattern, try alternative patterns
                    if (sections.length === 0) {
                        // Pattern 2: Format with section name outside brackets "Section 1 [Heading]: P1-P5"
                        regex = /S(?:ection)?\s*\d+\s*\[\s*(.*?)\s*\]\s*:\s*P(\d+)\s*-\s*P(\d+)/g;
                        
                        while ((match = regex.exec(response)) !== null) {
                            const heading = match[1].trim();
                            const startParagraph = parseInt(match[2]);
                            const endParagraph = parseInt(match[3]);
                            
                            if (heading && !isNaN(startParagraph) && !isNaN(endParagraph)) {
                                sections.push({
                                    heading,
                                    start: startParagraph,
                                    end: endParagraph
                                });
                            }
                        }
                    }
                    
                    // Pattern 3: Format with parentheses "Section 1: Heading (P1-P5)"
                    if (sections.length === 0) {
                        regex = /S(?:ection)?\s*\d+\s*:\s*(.*?)\s*\(\s*P(\d+)\s*-\s*P(\d+)\s*\)/g;
                        
                        while ((match = regex.exec(response)) !== null) {
                            const heading = match[1].trim();
                            const startParagraph = parseInt(match[2]);
                            const endParagraph = parseInt(match[3]);
                            
                            if (heading && !isNaN(startParagraph) && !isNaN(endParagraph)) {
                                sections.push({
                                    heading,
                                    start: startParagraph,
                                    end: endParagraph
                                });
                            }
                        }
                    }
                    
                    // Pattern 4: Format with no brackets "Section 1: Heading - P1-P5"
                    if (sections.length === 0) {
                        regex = /S(?:ection)?\s*\d+\s*:\s*(.*?)\s*-\s*P(\d+)\s*-\s*P(\d+)/g;
                        
                        while ((match = regex.exec(response)) !== null) {
                            const heading = match[1].trim();
                            const startParagraph = parseInt(match[2]);
                            const endParagraph = parseInt(match[3]);
                            
                            if (heading && !isNaN(startParagraph) && !isNaN(endParagraph)) {
                                sections.push({
                                    heading,
                                    start: startParagraph,
                                    end: endParagraph
                                });
                            }
                        }
                    }
                    
                    console.log(`Parsed ${sections.length} sections`);
                    return sections;
                };

                const adjustSectionStructure = (sectionStructure, isFirstBatch, isLastBatch, previousSectionEnd, batchStartIndex) => {
                    if (sectionStructure.length === 0) return [];
                    
                    // For non-first batches, we need to handle the overlap with the previous batch
                    let adjustedStructure = [...sectionStructure];
                    
                    if (!isFirstBatch && previousSectionEnd) {
                        // Remove any sections that are entirely within the overlap
                        adjustedStructure = adjustedStructure.filter(section => 
                            !(section.end <= previousSectionEnd - batchStartIndex)
                        );
                        
                        // Adjust the start of the first section if it overlaps with the previous batch
                        if (adjustedStructure.length > 0 && adjustedStructure[0].start <= previousSectionEnd - batchStartIndex) {
                            adjustedStructure[0].start = previousSectionEnd - batchStartIndex + 1;
                        }
                    }
                    
                    // Adjust indices to global paragraph positions
                    return adjustedStructure.map(section => ({
                        heading: section.heading,
                        start: section.start + batchStartIndex,
                        end: section.end + batchStartIndex
                    }));
                };

                const reconstructSections = (paragraphs, sectionStructure) => {
                    let result = '';
                    
                    // Sort sections by start index to ensure proper order
                    sectionStructure.sort((a, b) => a.start - b.start);
                    
                    // Track which paragraphs have been included
                    const includedParagraphs = new Set();
                    
                    // Check if we have any paragraphs before the first section
                    if (sectionStructure.length > 0 && sectionStructure[0].start > 1) {
                        result += `## Introduction\n\n`;
                        for (let i = 0; i < sectionStructure[0].start - 1; i++) {
                            if (i < paragraphs.length) {
                                result += paragraphs[i] + '\n\n';
                                includedParagraphs.add(i);
                            }
                        }
                    }
                    
                    // Process each section
                    let lastEnd = 0;
                    for (const section of sectionStructure) {
                        // Check if there are any paragraphs between the last section and this one
                        if (section.start > lastEnd + 1) {
                            result += `## Transition\n\n`;
                            for (let i = lastEnd; i < section.start - 1; i++) {
                                if (i < paragraphs.length && !includedParagraphs.has(i)) {
                                    result += paragraphs[i] + '\n\n';
                                    includedParagraphs.add(i);
                                }
                            }
                        }
                        
                        // Add section heading
                        result += `## ${section.heading}\n\n`;
                        
                        // Add paragraphs for this section
                        for (let i = section.start - 1; i < section.end; i++) {
                            if (i < paragraphs.length && !includedParagraphs.has(i)) {
                                result += paragraphs[i] + '\n\n';
                                includedParagraphs.add(i);
                            }
                        }
                        
                        lastEnd = section.end;
                    }
                    
                    // Add any remaining paragraphs without a section
                    if (lastEnd < paragraphs.length) {
                        result += `## Additional Content\n\n`;
                        for (let i = lastEnd; i < paragraphs.length; i++) {
                            if (!includedParagraphs.has(i)) {
                                result += paragraphs[i] + '\n\n';
                            }
                        }
                    }
                    
                    return result.trim();
                };

                const processSectionBatch = async (batch, previousSectionEnd, batchIndex, totalBatches) => {
                    sectionProgressStatus.value = `Processing batch ${batchIndex + 1} of ${totalBatches}...`;
                    
                    // Process this batch
                    const prompt = prepareSectionPrompt(batch.paragraphs);
                    const llmResponse = await callLLMService(prompt);
                    const sectionStructure = parseSectionStructure(llmResponse);
                    
                    if (sectionStructure.length === 0) {
                        throw new Error(`Failed to parse section structure for batch ${batchIndex + 1}`);
                    }
                    
                    // Adjust section structure based on batch position and previous batch
                    const adjustedStructure = adjustSectionStructure(
                        sectionStructure,
                        batchIndex === 0, // isFirstBatch
                        batchIndex === totalBatches - 1, // isLastBatch
                        previousSectionEnd,
                        batch.startIndex
                    );
                    
                    return adjustedStructure;
                };

                const processSections = async () => {
                    if (!outputText.value.trim() || isSectioning.value) return;
                    
                    if (!settings.value.apiKey) {
                        error.value = 'Please enter your API key in the settings';
                        showSettings.value = true;
                        return;
                    }
                    
                    isSectioning.value = true;
                    error.value = '';
                    sectionProgressPercent.value = 0;
                    sectionProgressStatus.value = 'Preparing to identify sections...';
                    
                    try {
                        // Split text into paragraphs
                        const paragraphs = outputText.value.split(/\n\n+/).filter(p => p.trim());
                        
                        if (paragraphs.length === 0) {
                            throw new Error('No valid paragraphs found in the input text');
                        }
                        
                        // For small texts, process in a single batch
                        if (paragraphs.length <= 20) {
                            sectionProgressStatus.value = 'Identifying sections...';
                            sectionProgressPercent.value = 30;
                            
                            // Prepare prompt for LLM
                            const prompt = prepareSectionPrompt(paragraphs);
                            
                            // Call LLM service
                            const llmResponse = await callLLMService(prompt);
                            sectionProgressPercent.value = 70;
                            
                            // Parse section structure from LLM response
                            const sectionStructure = parseSectionStructure(llmResponse);
                            
                            if (sectionStructure.length === 0) {
                                throw new Error('Failed to parse section structure from LLM response');
                            }
                            
                            // Reconstruct with sections
                            sectionProgressStatus.value = 'Reconstructing with sections...';
                            const sectionedResult = reconstructSections(paragraphs, sectionStructure);
                            
                            // Update output
                            sectionedText.value = sectionedResult;
                            sectionProgressPercent.value = 100;
                            sectionProgressStatus.value = 'Section identification complete!';
                        } else {
                            // Process in batches
                            const batchSize = 20;
                            
                            // First, create initial batches
                            const batches = createParagraphBatches(paragraphs, batchSize);
                            
                            sectionProgressStatus.value = `Processing text in ${batches.length} batches...`;
                            
                            // Process each batch
                            const allSectionStructures = [];
                            let previousSectionEnd = null;
                            
                            for (let i = 0; i < batches.length; i++) {
                                sectionProgressPercent.value = (i / batches.length) * 90; // Reserve 10% for final reconstruction
                                
                                console.log(`Processing batch ${i + 1}/${batches.length}, paragraphs ${batches[i].startIndex + 1}-${batches[i].endIndex + 1}`);
                                
                                // Process this batch
                                const batchStructure = await processSectionBatch(
                                    batches[i], 
                                    previousSectionEnd, 
                                    i, 
                                    batches.length
                                );
                                
                                allSectionStructures.push(...batchStructure);
                                
                                // For the next batch, we want to include the last section from this batch
                                if (batchStructure.length > 0) {
                                    const lastSection = batchStructure[batchStructure.length - 1];
                                    previousSectionEnd = lastSection.end;
                                    console.log(`Last section in batch ${i + 1} ends at paragraph ${previousSectionEnd}`);
                                }
                            }
                            
                            // Sort section structures by start index
                            allSectionStructures.sort((a, b) => a.start - b.start);
                            
                            // Merge overlapping sections
                            const mergedStructures = [];
                            for (const section of allSectionStructures) {
                                // Skip if this section is entirely contained within the previous one
                                if (mergedStructures.length > 0) {
                                    const lastSection = mergedStructures[mergedStructures.length - 1];
                                    if (section.start >= lastSection.start && section.end <= lastSection.end) {
                                        continue;
                                    }
                                    
                                    // Merge with previous section if they overlap
                                    if (section.start <= lastSection.end) {
                                        // Use the heading from the larger section
                                        if (section.end > lastSection.end) {
                                            lastSection.heading = section.heading;
                                        }
                                        lastSection.end = Math.max(lastSection.end, section.end);
                                        continue;
                                    }
                                }
                                
                                mergedStructures.push(section);
                            }
                            
                            // Reconstruct with sections
                            sectionProgressStatus.value = 'Reconstructing with sections...';
                            sectionProgressPercent.value = 95;
                            const sectionedResult = reconstructSections(paragraphs, mergedStructures);
                            
                            // Update output
                            sectionedText.value = sectionedResult;
                            sectionProgressPercent.value = 100;
                            sectionProgressStatus.value = 'Section identification complete!';
                        }
                    } catch (e) {
                        error.value = e.message;
                        console.error('Section processing error:', e);
                    } finally {
                        isSectioning.value = false;
                    }
                };

                const copyToClipboard = (type) => {
                    const text = type === 'sectioned' ? sectionedText.value : outputText.value;
                    if (!text) return;
                    
                    navigator.clipboard.writeText(text)
                        .then(() => {
                            copied.value = type;
                            setTimeout(() => {
                                copied.value = '';
                            }, 2000);
                        })
                        .catch(e => {
                            error.value = 'Failed to copy to clipboard';
                            console.error('Clipboard error:', e);
                        });
                };

                // Lifecycle hooks
                onMounted(() => {
                    loadSettings();
                    
                    // Try to load saved text from localStorage
                    const savedInput = localStorage.getItem('paragraphSplitterInput');
                    if (savedInput) {
                        inputText.value = savedInput;
                    }
                });

                // Save input text to localStorage when it changes
                watch(inputText, (newValue) => {
                    localStorage.setItem('paragraphSplitterInput', newValue);
                });

                return {
                    inputText,
                    outputText,
                    sectionedText,
                    isProcessing,
                    isSectioning,
                    copied,
                    showSettings,
                    error,
                    progressPercent,
                    progressStatus,
                    sectionProgressPercent,
                    sectionProgressStatus,
                    settings,
                    inputStats,
                    outputStats,
                    sectionedStats,
                    processText,
                    processSections,
                    copyToClipboard,
                    saveSettings
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
